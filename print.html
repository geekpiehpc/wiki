<!DOCTYPE HTML>
<html lang="cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>GeekPie_HPC Wiki</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
                <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Algorithm/index.html"><strong aria-hidden="true">1.</strong> Algorithm</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Algorithm/dgemm.html"><strong aria-hidden="true">1.1.</strong> Dgemm</a></li><li class="chapter-item expanded "><a href="Algorithm/kmer.html"><strong aria-hidden="true">1.2.</strong> Kmer</a></li></ol></li><li class="chapter-item expanded "><a href="Apps/index.html"><strong aria-hidden="true">2.</strong> Apps</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Apps/ASC/index.html"><strong aria-hidden="true">2.1.</strong> ASC</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Apps/ASC/asc-19/index.html"><strong aria-hidden="true">2.1.1.</strong> Asc 19</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Apps/ASC/asc-19/cesm.html"><strong aria-hidden="true">2.1.1.1.</strong> Cesm</a></li></ol></li><li class="chapter-item expanded "><a href="Apps/ASC/asc-20/index.html"><strong aria-hidden="true">2.1.2.</strong> Asc 20</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Apps/ASC/asc-20/quest.html"><strong aria-hidden="true">2.1.2.1.</strong> Quest</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="Apps/ISC/index.html"><strong aria-hidden="true">2.2.</strong> ISC</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Apps/ISC/ISC-21/index.html"><strong aria-hidden="true">2.2.1.</strong> ISC 21</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Apps/ISC/ISC-21/CodeChallenge.html"><strong aria-hidden="true">2.2.1.1.</strong> Code Challenge</a></li><li class="chapter-item expanded "><a href="Apps/ISC/ISC-21/WRF.html"><strong aria-hidden="true">2.2.1.2.</strong> WRF</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="Apps/SC/index.html"><strong aria-hidden="true">2.3.</strong> SC</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Apps/SC/SC20.html"><strong aria-hidden="true">2.3.1.</strong> SC 20</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="Benchmark/index.html"><strong aria-hidden="true">3.</strong> Benchmark</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Benchmark/hpcg-dat.html"><strong aria-hidden="true">3.1.</strong> Hpcg Dat</a></li><li class="chapter-item expanded "><a href="Benchmark/hpl-dat.html"><strong aria-hidden="true">3.2.</strong> Hpl Dat</a></li></ol></li><li class="chapter-item expanded "><a href="DevOps/index.html"><strong aria-hidden="true">4.</strong> Dev Ops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="DevOps/LDAP.html"><strong aria-hidden="true">4.1.</strong> LDAP</a></li><li class="chapter-item expanded "><a href="DevOps/SaltStack.html"><strong aria-hidden="true">4.2.</strong> Salt Stack</a></li><li class="chapter-item expanded "><a href="DevOps/Schduler.html"><strong aria-hidden="true">4.3.</strong> Schduler</a></li><li class="chapter-item expanded "><a href="DevOps/Singularity.html"><strong aria-hidden="true">4.4.</strong> Singularity</a></li></ol></li><li class="chapter-item expanded "><a href="Language/index.html"><strong aria-hidden="true">5.</strong> Language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Language/Chisel.html"><strong aria-hidden="true">5.1.</strong> Chisel</a></li><li class="chapter-item expanded "><a href="Language/Go.html"><strong aria-hidden="true">5.2.</strong> Go</a></li><li class="chapter-item expanded "><a href="Language/Rust.html"><strong aria-hidden="true">5.3.</strong> Rust</a></li></ol></li><li class="chapter-item expanded "><a href="Libs/index.html"><strong aria-hidden="true">6.</strong> Libs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Libs/Boost.html"><strong aria-hidden="true">6.1.</strong> Boost</a></li></ol></li><li class="chapter-item expanded "><a href="Profiling/index.html"><strong aria-hidden="true">7.</strong> Profiling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Profiling/ArmForge.html"><strong aria-hidden="true">7.1.</strong> Arm Forge</a></li><li class="chapter-item expanded "><a href="Profiling/uProf.html"><strong aria-hidden="true">7.2.</strong> U Prof</a></li><li class="chapter-item expanded "><a href="Profiling/Vtune.html"><strong aria-hidden="true">7.3.</strong> Vtune</a></li></ol></li><li class="chapter-item expanded "><a href="Sysadmin/index.html"><strong aria-hidden="true">8.</strong> Sysadmin</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Sysadmin/cluster-setup.html"><strong aria-hidden="true">8.1.</strong> Cluster Setup</a></li><li class="chapter-item expanded "><a href="Sysadmin/environment-installation.html"><strong aria-hidden="true">8.2.</strong> Environment Installation</a></li><li class="chapter-item expanded "><a href="Sysadmin/environment-modules.html"><strong aria-hidden="true">8.3.</strong> Environment Modules</a></li><li class="chapter-item expanded "><a href="Sysadmin/machine.html"><strong aria-hidden="true">8.4.</strong> Machine</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">GeekPie_HPC Wiki</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/geekpiehpc/wiki" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="algorithm"><a class="header" href="#algorithm">Algorithm</a></h1>
<p>这里放置有关应用和测试中常见的算法。</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="applications"><a class="header" href="#applications">Applications</a></h1>
<p>这里放置<code>GeekPie_HPC</code>参与过各个竞赛中的应用的经历和经验</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><!-- TITLE: CESM -->
<!-- SUBTITLE: CESM summary -->
<h1 id="cesm"><a class="header" href="#cesm">CESM</a></h1>
<h2 id="build--running"><a class="header" href="#build--running">Build &amp; Running</a></h2>
<h3 id="onekeyconf"><a class="header" href="#onekeyconf">OneKeyConf</a></h3>
<pre><code class="language-bash">./create_newcase -res 0.47x0.63_gx1v6 -compset B -case ../EXP2 -mach pleiades-ivy
mkdir nobackup
ln -s /home/cesm/data/inputdata_EXP1/ nobackup/inputdata
# EXP1: ./xmlchange -file env_run.xml -id DOCN_SOM_FILENAME -val pop_frc.gx1v6.091112.nc
./xmlchange -file env_build.xml -id CESMSCRATCHROOT -val `pwd`'/nobackup/$USER'
./xmlchange -file env_build.xml -id EXEROOT -val `pwd`'/nobackup/$CCSMUSER/$CASE/bld'
./xmlchange -file env_run.xml -id RUNDIR -val `pwd`'/nobackup/$CCSMUSER/$CASE/run'
./xmlchange -file env_run.xml -id DIN_LOC_ROOT -val `pwd`'/nobackup/inputdata'
./xmlchange -file env_run.xml -id DIN_LOC_ROOT_CLMFORC -val `pwd`'/nobackup/inputdata/atm/datm7'
./xmlchange -file env_run.xml -id DOUT_S_ROOT -val `pwd`'/nobackup/$CCSMUSER/archive/$CASE'
./xmlchange -file env_run.xml -id RUN_STARTDATE -val 2000-01-01
./xmlchange -file env_build.xml -id BUILD_THREADED -val TRUE
# edit Macro SLIBS -lnetcdff
# edit env_mach_specific
./cesm_setup
</code></pre>
<h3 id="ybssh"><a class="header" href="#ybssh">ybs.sh</a></h3>
<pre><code class="language-bash">./EXP2.clean_build all
./cesm_setup -clean
rm -rf $build_dir
./cesm_setup
./EXP2.build
</code></pre>
<h3 id="pbs"><a class="header" href="#pbs">PBS</a></h3>
<pre><code>##PBS -N dappur
##PBS -q pub_blad_2
##PBS -j oe
##PBS -l walltime=00:01:00
##PBS -l nodes=1:ppn=28
</code></pre>
<h2 id="performance-tuning"><a class="header" href="#performance-tuning">Performance Tuning</a></h2>
<h2 id="trouble-shooting"><a class="header" href="#trouble-shooting">Trouble Shooting</a></h2>
<h3 id="high-sys-percentage-in-top-20"><a class="header" href="#high-sys-percentage-in-top-20">High sys percentage in top (&gt;20%)</a></h3>
<p>This is apparent this is a communication problem. Try switching to Intel MPI for a terribly low sys percentage (&lt;1%).</p>
<h3 id="error-remap-transport-bad-departure-points"><a class="header" href="#error-remap-transport-bad-departure-points">ERROR: remap transport: bad departure points</a></h3>
<pre><code>Warning: Departure points out of bounds in remap                  
 my_task, i, j =         182           4           8              
 dpx, dpy =  -5925130.21408796      -0.368922055964299            
 HTN(i,j), HTN(i+1,j) =   72848.1354852604        72848.1354852604
 HTE(i,j), HTE(i,j+1) =   59395.4550164223        59395.4550164223
 istep1, my_task, iblk =     1095001         182           1      
 Global block:         205                                        
 Global i and j:          35          47                          
(shr_sys_abort) ERROR: remap transport: bad departure points      
(shr_sys_abort) WARNING: calling shr_mpi_abort() and stopping     
application called MPI_Abort(MPI_COMM_WORLD, 1001) - process 182
</code></pre>
<p>This error may due to multiple reasons.</p>
<p>One significant one is the bad grid division. We were once using one PE for every processor core so the total number of PEs is not a power of 2. Then we used 128 (or later 256) and the error diminished until it showed up again after 6mos of simulation...</p>
<p>Then another affecting reason is the parameter xndt_dyn, see link. This parameter has already been set to 2 after solving the last problem (originally 1). Then we tried increasing this parameter again, it passed the 6mos simulation, but crashed again after another 3mos. We then continued increasing the value, but it crashes faster. We stopped at about 20mos simulation and turned to GNU compiler version with Intel MPI.</p>
<p>However, this does not mean it's the fault of Intel compiler. Direct comparison between Intel and GNU compilers is unfair because the combination of Intel compiler xndt_dyn=1 and most importantly the correct PE number has not been tried. Maybe try using xndt_dyn=1 from be beginning next time, using Intel compiler.</p>
<h3 id="openmp-failed"><a class="header" href="#openmp-failed">OpenMP failed</a></h3>
<p>Still no solved, but very promising for improving performance.</p>
<p>fixed in <a href="Apps/ASC/asc-19/../../ISC/ISC-21/WRF.html">WRF</a></p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><!-- TITLE: Quest -->
<!-- SUBTITLE: A quick summary of Quest -->
<h1 id="quest-analysis"><a class="header" href="#quest-analysis">quest analysis</a></h1>
<h2 id="program-goal-analysis"><a class="header" href="#program-goal-analysis">program goal analysis</a></h2>
<p>what's code is actually doing is to simulate quantum computing.</p>
<img src="https://www.victoryang00.cn/picture/image-20200206175943861.png" alt="image-20200206175943861" style="zoom:33%;" />
<h3 id="different-bits-state---qubits"><a class="header" href="#different-bits-state---qubits">different bits state - qubits</a></h3>
<p>3 states: <code>1</code> <code>0</code> <code>0/1</code></p>
<p>store by qreal which is actualy a complex number a+bi  (a+b=1), and it can be stated as $\bigl(\begin{smallmatrix}0.123124&amp;0\0&amp;0.876876\end{smallmatrix})$ , also note that because gpu only support float32 computing. So native qreal (precision=4) is not supported in gpu simutation.</p>
<pre><code class="language-cpp">/*
 * Single precision, which uses 4 bytes per amplitude component
 */
# if QuEST_PREC==1
    # define qreal float
    // \cond HIDDEN_SYMBOLS   
    # define MPI_QuEST_REAL MPI_FLOAT
    # define MPI_MAX_AMPS_IN_MSG (1LL&lt;&lt;29) // must be 2^int
    # define REAL_STRING_FORMAT &quot;%.8f&quot;
    # define REAL_QASM_FORMAT &quot;%.8g&quot;
    # define REAL_EPS 1e-5
    # define absReal(X) fabs(X) // not fabsf(X) - better to return doubles where possible
    // \endcond
/*
 * Double precision, which uses 8 bytes per amplitude component
 */
# elif QuEST_PREC==2
    # define qreal double
    // \cond HIDDEN_SYMBOLS   
    # define MPI_QuEST_REAL MPI_DOUBLE
    # define MPI_MAX_AMPS_IN_MSG (1LL&lt;&lt;28) // must be 2^int
    # define REAL_STRING_FORMAT &quot;%.14f&quot;
    # define REAL_QASM_FORMAT &quot;%.14g&quot;
    # define REAL_EPS 1e-13
    # define absReal(X) fabs(X)
    // \endcond
/*
 * Quad precision, which uses 16 bytes per amplitude component.
 * This is not compatible with most GPUs.
 */
# elif QuEST_PREC==4
    # define qreal long double
    // \cond HIDDEN_SYMBOLS   
    # define MPI_QuEST_REAL MPI_LONG_DOUBLE
    # define MPI_MAX_AMPS_IN_MSG (1LL&lt;&lt;27) // must be 2^int
    # define REAL_STRING_FORMAT &quot;%.17Lf&quot;
    # define REAL_QASM_FORMAT &quot;%.17Lg&quot;
    # define REAL_EPS 1e-14
    # define absReal(X) fabsl(X)
    // \endcond
# endif
</code></pre>
<h3 id="many-matrices-computation"><a class="header" href="#many-matrices-computation">many matrices computation</a></h3>
<img src="https://www.victoryang00.cn/picture/image-20200206182352740.png" alt="image-20200206182352740" style="zoom:33%;" />
<p>all of the gate corresponds to one of the manipulation on qubits.</p>
<h4 id="basic-operation-on-a-and-b-httpsarxivorgpdfquant-ph0207118pdf"><a class="header" href="#basic-operation-on-a-and-b-httpsarxivorgpdfquant-ph0207118pdf">Basic operation on a and b https://arxiv.org/pdf/quant-ph/0207118.pdf</a></h4>
<p>random variables = density matrix </p>
<p><strong>hermitian</strong>:$\rho^T=\rho$</p>
<p><strong>positive semidefinite</strong>:  <strong>eigenvalue</strong> $\geq$ 0</p>
<p><strong>trace</strong>: $\Sigma(diagnal\ elements)=1$</p>
<p>dirac notation: ket $v_{\phi}=|\phi\rangle=\left(\begin{array}{l}\phi_{0} \\phi_{1}\end{array}\right)$</p>
<p>bra   $ v_{\phi}^T=\langle\phi|=\left(\begin{array}{ll}\phi_{0} &amp; \phi_{1}\end{array}\right)$</p>
<p>$\langle\phi \mid \psi\rangle$= inner products of bra(fi) and ket(theta). notice: $\langle\phi \mid \phi\rangle=1$</p>
<p>$|\phi\rangle|\psi\rangle$=tensor product of ket(fi) and bra(theta)</p>
<p>2 special notation: $u_{0}=|0\rangle=\left(\begin{array}{l}1 \0\end{array}\right) \quad v_{1}=|1\rangle=\left(\begin{array}{l}0 \1\end{array}\right)$</p>
<p>the dense <strong>matrix</strong>:$\rho=\left(\begin{array}{cc}q_{0} &amp; 0 \0 &amp; q_{1}\end{array}\right)$ ($q_{0}+q_{1}=1$, the purpose of the equation is to illustrate the complex number ) can be stated  as $\rho=q_{0}|0\rangle\left\langle 0\left|+q_{1}\right| 1\right\rangle\langle 1|$</p>
<p>so $\rho|0\rangle=\left(q_{0}|0\rangle\left\langle 0\left|+q_{1}\right| 1\right\rangle\langle 1|\right)|0\rangle=q_{0}|0\rangle$</p>
<p>dot product (from normal bits to qubits):$|a b\rangle=|a\rangle \otimes|b\rangle=v_{00}|00\rangle+v_{01}|01\rangle+v_{10}|10\rangle \dashv v_{11}|11\rangle \rightarrow\left[\begin{array}{l}v_{00} \v_{01} \v_{10} \v_{11}\end{array}\right]$</p>
<p>for example in bits 5 = 101b, while in qubits $|5\rangle_{3}=|101\rangle=|1\rangle|0\rangle|1\rangle=\left(\begin{array}{l}0 \1\end{array}\right)\left(\begin{array}{l}1 \0\end{array}\right)\left(\begin{array}{l}0 \1\end{array}\right)=\left(\begin{array}{l}0 \0 \0 \0 \0 \1 \0 \0\end{array}\right)$</p>
<img src="https://www.victoryang00.cn/picture/image-20200206193126579.png" alt="graph" style="zoom:100%;" />
<h4 id="hadamard-gate-operations"><a class="header" href="#hadamard-gate-operations">Hadamard gate operations</a></h4>
<p>$$\begin{aligned}H(|0\rangle) &amp;=\frac{1}{\sqrt{2}}|0\rangle+\frac{1}{\sqrt{2}}|1\rangle=:|+\rangle \H(|1\rangle) &amp;=\frac{1}{\sqrt{2}}|0\rangle-\frac{1}{\sqrt{2}}|1\rangle=:|-\rangle \H\left(\frac{1}{\sqrt{2}}|0\rangle+\frac{1}{\sqrt{2}}|1\rangle\right) &amp;=\frac{1}{2}(|0\rangle+|1\rangle)+\frac{1}{2}(|0\rangle-|1\rangle)=|0\rangle \H\left(\frac{1}{\sqrt{2}}|0\rangle-\frac{1}{\sqrt{2}}|1\rangle\right) &amp;=\frac{1}{2}(|0\rangle+|1\rangle)-\frac{1}{2}(|0\rangle-|1\rangle)=|1\rangle\end{aligned}$$</p>
<p>corresponding matrix operation in dirac notation: $H_{1}=\frac{1}{\sqrt{2}}\left(\begin{array}{cc}1 &amp; 1 \1 &amp; -1\end{array}\right)$</p>
<p>some specialty:</p>
<ol>
<li>$H=\frac{|0\rangle+|1\rangle}{\sqrt{2}}\langle 0|+\frac{|0\rangle-|1\rangle}{\sqrt{2}}\langle 1|$</li>
<li>Since <img src="https://www.victoryang00.cn/picture/6390e45c284a61ae56967efa897265f7c676116a.svg" alt="graph" style="zoom:100%;" /> where <em>I</em> is the identity matrix, <em>H</em> is a <a href="https://en.wikipedia.org/wiki/Unitary_matrix">unitary matrix</a> (like all other quantum logical gates). Also, it is its own <a href="https://en.wikipedia.org/wiki/Unitary_matrix">unitary inverse</a>, <img src="https://www.victoryang00.cn/picture/67587a10e5b72c23dc1e91b7e197e82315f70288.svg" alt="graph" style="zoom:100%;" />.</li>
</ol>
<p>One application of the Hadamard gate to either a 0 or 1 qubit will produce a quantum state that, if observed, will be a 0 or 1 with equal probability (as seen in the first two operations). This is exactly like flipping a fair coin in the standard <a href="https://en.wikipedia.org/wiki/Probabilistic_Turing_machine">probabilistic model of computation</a>. However, if the Hadamard gate is applied twice in succession (as is effectively being done in the last two operations), then the final state is always the same as the initial state.</p>
<pre><code class="language-cpp">__global__ void statevec_hadamardKernel (Qureg qureg, const int targetQubit){
    // ----- sizes
    long long int sizeBlock,                                           // size of blocks
         sizeHalfBlock;                                       // size of blocks halved
    // ----- indices
    long long int thisBlock,                                           // current block
         indexUp,indexLo;                                     // current index and corresponding index in lower half block

    // ----- temp variables
    qreal   stateRealUp,stateRealLo,                             // storage for previous state values
           stateImagUp,stateImagLo;                             // (used in updates)
    // ----- temp variables
    long long int thisTask;                                   // task based approach for expose loop with small granularity
    const long long int numTasks=qureg.numAmpsPerChunk&gt;&gt;1;

    sizeHalfBlock = 1LL &lt;&lt; targetQubit;                               // size of blocks halved
    sizeBlock     = 2LL * sizeHalfBlock;                           // size of blocks

    // ---------------------------------------------------------------- //
    //            rotate                                                //
    // ---------------------------------------------------------------- //

    //! fix -- no necessary for GPU version
    qreal *stateVecReal = qureg.deviceStateVec.real;
    qreal *stateVecImag = qureg.deviceStateVec.imag;

    qreal recRoot2 = 1.0/sqrt(2.0);

    thisTask = blockIdx.x*blockDim.x + threadIdx.x;
    if (thisTask&gt;=numTasks) return;

    thisBlock   = thisTask / sizeHalfBlock;
    indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
    indexLo     = indexUp + sizeHalfBlock;

    // store current state vector values in temp variables
    stateRealUp = stateVecReal[indexUp];
    stateImagUp = stateVecImag[indexUp];

    stateRealLo = stateVecReal[indexLo];
    stateImagLo = stateVecImag[indexLo];

    stateVecReal[indexUp] = recRoot2*(stateRealUp + stateRealLo);
    stateVecImag[indexUp] = recRoot2*(stateImagUp + stateImagLo);

    stateVecReal[indexLo] = recRoot2*(stateRealUp - stateRealLo);
    stateVecImag[indexLo] = recRoot2*(stateImagUp - stateImagLo);
}

void statevec_hadamard(Qureg qureg, const int targetQubit) 
{
    int threadsPerCUDABlock, CUDABlocks;
    threadsPerCUDABlock = 128;
    CUDABlocks = ceil((qreal)(qureg.numAmpsPerChunk&gt;&gt;1)/threadsPerCUDABlock);
    statevec_hadamardKernel&lt;&lt;&lt;CUDABlocks, threadsPerCUDABlock&gt;&gt;&gt;(qureg, targetQubit);
}
</code></pre>
<h4 id="pauli-xyz-gate"><a class="header" href="#pauli-xyz-gate">Pauli-X/Y/Z gate</a></h4>
<p>The Pauli-X gate acts on a single qubit. It is the quantum equivalent of the $X=\left[\begin{array}{ll}0 &amp; 1 \1 &amp; 0\end{array}\right]$</p>
<pre><code class="language-cpp">void pauliX(Qureg qureg, const int targetQubit) {
    validateTarget(qureg, targetQubit, __func__);
    
    statevec_pauliX(qureg, targetQubit);
    if (qureg.isDensityMatrix) {
        statevec_pauliX(qureg, targetQubit+qureg.numQubitsRepresented);
    }
    
    qasm_recordGate(qureg, GATE_SIGMA_X, targetQubit);
}
</code></pre>
<p>the real computing part</p>
<pre><code class="language-cpp">void statevec_pauliXLocal(Qureg qureg, const int targetQubit)
{
    long long int sizeBlock, sizeHalfBlock;
    long long int thisBlock, // current block
         indexUp,indexLo;    // current index and corresponding index in lower half block

    qreal stateRealUp,stateImagUp;
    long long int thisTask;         
    const long long int numTasks=qureg.numAmpsPerChunk&gt;&gt;1;

    // set dimensions
    sizeHalfBlock = 1LL &lt;&lt; targetQubit;  
    sizeBlock     = 2LL * sizeHalfBlock; 

    // Can't use qureg.stateVec as a private OMP var
    qreal *stateVecReal = qureg.stateVec.real;
    qreal *stateVecImag = qureg.stateVec.imag;

# ifdef _OPENMP
# pragma omp parallel \
    default  (none) \
    shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
    private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) 
# endif
    {
# ifdef _OPENMP
# pragma omp for schedule (static)
# endif
        for (thisTask=0; thisTask&lt;numTasks; thisTask++) {
            thisBlock   = thisTask / sizeHalfBlock;
            indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
            indexLo     = indexUp + sizeHalfBlock;

            stateRealUp = stateVecReal[indexUp];
            stateImagUp = stateVecImag[indexUp];

            stateVecReal[indexUp] = stateVecReal[indexLo];
            stateVecImag[indexUp] = stateVecImag[indexLo];

            stateVecReal[indexLo] = stateRealUp;
            stateVecImag[indexLo] = stateImagUp;
        } 
    }

}

void statevec_pauliXDistributed (Qureg qureg,
        ComplexArray stateVecIn,
        ComplexArray stateVecOut)
{

    long long int thisTask;  
    const long long int numTasks=qureg.numAmpsPerChunk;

    qreal *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
    qreal *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.imag;

# ifdef _OPENMP
# pragma omp parallel \
    default  (none) \
    shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) \
    private  (thisTask)
# endif
    {
# ifdef _OPENMP
# pragma omp for schedule (static)
# endif
        for (thisTask=0; thisTask&lt;numTasks; thisTask++) {
            stateVecRealOut[thisTask] = stateVecRealIn[thisTask];
            stateVecImagOut[thisTask] = stateVecImagIn[thisTask];
        }
    }
} 
</code></pre>
<pre><code class="language-cpp">__global__ void statevec_pauliXKernel(Qureg qureg, const int targetQubit){
    // ----- sizes
    long long int sizeBlock,                                           // size of blocks
         sizeHalfBlock;                                       // size of blocks halved
    // ----- indices
    long long int thisBlock,                                           // current block
         indexUp,indexLo;                                     // current index and corresponding index in lower half block

    // ----- temp variables
    qreal   stateRealUp,                             // storage for previous state values
           stateImagUp;                             // (used in updates)
    // ----- temp variables
    long long int thisTask;                                   // task based approach for expose loop with small granularity
    const long long int numTasks=qureg.numAmpsPerChunk&gt;&gt;1;

    sizeHalfBlock = 1LL &lt;&lt; targetQubit;                               // size of blocks halved
    sizeBlock     = 2LL * sizeHalfBlock;                           // size of blocks

    // ---------------------------------------------------------------- //
    //            rotate                                                //
    // ---------------------------------------------------------------- //

    //! fix -- no necessary for GPU version
    qreal *stateVecReal = qureg.deviceStateVec.real;
    qreal *stateVecImag = qureg.deviceStateVec.imag;

    thisTask = blockIdx.x*blockDim.x + threadIdx.x;
    if (thisTask&gt;=numTasks) return;

    thisBlock   = thisTask / sizeHalfBlock;
    indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
    indexLo     = indexUp + sizeHalfBlock;

    // store current state vector values in temp variables
    stateRealUp = stateVecReal[indexUp];
    stateImagUp = stateVecImag[indexUp];

    stateVecReal[indexUp] = stateVecReal[indexLo];
    stateVecImag[indexUp] = stateVecImag[indexLo];

    stateVecReal[indexLo] = stateRealUp;
    stateVecImag[indexLo] = stateImagUp;
}

void statevec_pauliX(Qureg qureg, const int targetQubit) 
{
    int threadsPerCUDABlock, CUDABlocks;
    threadsPerCUDABlock = 128;
    CUDABlocks = ceil((qreal)(qureg.numAmpsPerChunk&gt;&gt;1)/threadsPerCUDABlock);
    statevec_pauliXKernel&lt;&lt;&lt;CUDABlocks, threadsPerCUDABlock&gt;&gt;&gt;(qureg, targetQubit);
}
</code></pre>
<h2 id="source-code-analysis"><a class="header" href="#source-code-analysis">source code analysis</a></h2>
<h4 id="tree"><a class="header" href="#tree">tree</a></h4>
<pre><code class="language-bash">.
├── CMakeLists.txt
├── include
│   ├── QuEST_complex.h				 //determine to use native external cpp support or c complex support.
│   ├── QuEST.h								  //main func claim
│   └── QuEST_precision.h				//define the precision
└── src
    ├── CMakeLists.txt
    ├── CPU
    │   ├── CMakeLists.txt
    │   ├── QuEST_cpu.c
    │   ├── QuEST_cpu_distributed.c	//distributed activator and implementation
    │   ├── QuEST_cpu_internal.h		 //other cpu related headers here
    │   └── QuEST_cpu_local.c			   //only cpu implementation
    ├── GPU
    │   ├── CMakeLists.txt
    │   └── QuEST_gpu.cu 					 //gpu counterpart
    ├── mt19937ar.c							  //梅森旋轉算法-伪随机数矩阵生成
    ├── mt19937ar.h
    ├── QuEST.c										//main func definition
    ├── QuEST_common.c					  //func activator defined here
    ├── QuEST_debug.h						  //debug information here
    ├── QuEST_internal.h
    ├── QuEST_qasm.c							//is a quantum record standard, defined qasm assertion here.
    ├── QuEST_qasm.h
    ├── QuEST_validation.c					//assert number of qubit here
    └── QuEST_validation.h
</code></pre>
<p>https://www.quantum-inspire.com/kbase/introduction-to-quantum-computing</p>
<h2 id="testcase-analysis"><a class="header" href="#testcase-analysis">testcase analysis</a></h2>
<p><code>mytimer.hpp</code></p>
<pre><code class="language-cpp">#include &lt;time.h&gt;
#include &lt;sys/time.h&gt;
 
 double get_wall_time(){
 /* A time value that is accurate to the nearest
   microsecond but also has a range of years.  */
   struct timeval time;
 // __time_t tv_sec;		/* Seconds.  */
 // __suseconds_t tv_usec;	/* Microseconds.  */
   if (gettimeofday(&amp;time,NULL)){
     // Handle error
     return 0;
   }
 
   return (double)time.tv_sec + (double)time.tv_usec * .000001;
 }
 
 double get_cpu_time(){
   return (double)clock() / CLOCKS_PER_SEC;//directly read clock from cpu, and return with clock times cloacks per sec.
 }```
</code></pre>
<p><code>random.c</code> - random manipulation</p>
<pre><code class="language-cpp">// total number of qubit: 30
// total number of qubit operatations: 667
// estimated time: 3783.9266747315614 second.
#include &quot;QuEST.h&quot;
#include &quot;mytimer.hpp&quot;
#include &quot;stdio.h&quot;

int main(int narg, char *argv[])
{

    QuESTEnv Env = createQuESTEnv();
    double t1 = get_wall_time();//define starting time 

    FILE *fp = fopen(&quot;probs.dat&quot;, &quot;w&quot;);//open file for result
    if (fp == NULL) {
        printf(&quot;    open probs.dat failed, Bye!&quot;);
        return 0;
    }

    FILE *fvec = fopen(&quot;stateVector.dat&quot;, &quot;w&quot;);
    if (fp == NULL) {
        printf(&quot;    open stateVector.dat failed, Bye!&quot;);
        return 0;
    }

    Qureg q =  createQureg(30, Env);//define qubits registers

    float q_measure[30];// defined q's size
   // possible execution.
    tGate(q, 25);
    controlledNot(q, 28, 21);
    controlledRotateX(q, 17, 5, 0.3293660327520663);
    tGate(q, 3);
    rotateX(q, 10, 4.734238389048838);
    rotateY(q, 8, 4.959946047271496);
    rotateZ(q, 5, 1.0427019597472071);
    pauliZ(q, 0);
	...
        
    printf(&quot;\n&quot;);
    for (long long int i = 0; i &lt; 30; ++i) {
        q_measure[i] = calcProbOfOutcome(q, i, 1);
        printf(&quot;  probability for q[%2lld]==1 : %lf    \n&quot;, i, q_measure[i]);
        fprintf(fp, &quot;Probability for q[%2lld]==1 : %lf    \n&quot;, i, q_measure[i]);
    }
    fprintf(fp, &quot;\n&quot;);
    printf(&quot;\n&quot;);

    for (int i = 0; i &lt; 10; ++i) {
        Complex amp = getAmp(q, i);
        printf(&quot;Amplitude of %dth state vector: %12.6f,%12.6f\n&quot;, i, amp.real,
               amp.imag);
    }

    double t2 = get_wall_time();
    printf(&quot;Complete the simulation takes time %12.6f seconds.&quot;, t2 - t1);
    printf(&quot;\n&quot;);
    destroyQureg(q, Env);
    destroyQuESTEnv(Env);

    return 0;
}
</code></pre>
<p><code>GHZ_QFT.c</code> - only controlled manipulation</p>
<pre><code class="language-cpp">/* GHZ quantum circuit */
    hadamard(q, 0);
    controlledNot(q, 0, 1);
    controlledNot(q, 1, 2);
    controlledNot(q, 2, 3);
    controlledNot(q, 3, 4);
    controlledNot(q, 4, 5);
    controlledNot(q, 5, 6);
    controlledNot(q, 6, 7);
    controlledNot(q, 7, 8);
    controlledNot(q, 8, 9);
    controlledNot(q, 9, 10);
    controlledNot(q, 10, 11);
    controlledNot(q, 11, 12);
    controlledNot(q, 12, 13);
    controlledNot(q, 13, 14);
    controlledNot(q, 14, 15);
    controlledNot(q, 15, 16);
    controlledNot(q, 16, 17);
    controlledNot(q, 17, 18);
    controlledNot(q, 18, 19);
    controlledNot(q, 19, 20);
    controlledNot(q, 20, 21);
    controlledNot(q, 21, 22);
    controlledNot(q, 22, 23);
    controlledNot(q, 23, 24);
    controlledNot(q, 24, 25);
    controlledNot(q, 25, 26);
    controlledNot(q, 26, 27);
    controlledNot(q, 27, 28);
    controlledNot(q, 28, 29);
	/* end of GHZ circuit */

	/* QFT starts */
    hadamard(q, 0);
    controlledRotateZ(q, 0, 1, 1.5708);
    hadamard(q, 1);
    controlledRotateZ(q, 0, 2, 0.785398);
    controlledRotateZ(q, 1, 2, 1.5708);
    hadamard(q, 2);
    controlledRotateZ(q, 0, 3, 0.392699);
    controlledRotateZ(q, 1, 3, 0.785398);
    controlledRotateZ(q, 2, 3, 1.5708);
    ...
</code></pre>
<h2 id="available-test-machine"><a class="header" href="#available-test-machine">available test machine</a></h2>
<ol>
<li>
<p>2node 16core each <code>mpi:omp=2:16</code></p>
<pre><code class="language-bash">#!/bin/sh
module purge
spack load intel ##openmpi@3.1.5/3.1.2
export PRECISION=4 ##1/2/4
CC=icc CXX=icpc cmake -DGPUACCELERATED=0 -DDISTRIBUTED=1 ..
make
export OMP_NUM_THREADS=16
export FI_PROVIDER=tcp
mpirun -machinefile mac -np 2 ./demo 
</code></pre>
<p>profiling result</p>
<img src="https://www.victoryang00.cn/picture/image-20200206174728724.png" alt="graph" style="zoom:100%;" />
<img src="https://www.victoryang00.cn/picture/image-20200206174748013.png" alt="graph" style="zoom:100%;" />
<p>the most time-consuming part is statevec_compactUnitaryLocal</p>
</li>
<li>
<p>2node 16core each <code>mpi:omp=1:32</code></p>
<img src="https://www.victoryang00.cn/picture/image-20200206180552841.png" alt="image-20200206180552841" style="zoom:33%;" />
</li>
<li>
<p>1node 1tesla v100</p>
<p>script</p>
<pre><code class="language-bash">#!/bin/sh
module purge
spack load gcc@6
spack load cuda@10.1 ## 10.2
export PATH=$PATH:/usr/local/cuda/bin
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda/lib64
export LIBRARY_PATH=$LIBRARY_PATH:/usr/local/cuda/lib64

export PRECISION=2 ##1/2
CC=gcc CXX=g++ cmake -DGPUACCELERATED=1 -DGPU_COMPUTE_CAPABILIty=70 ..
make
./demo 
</code></pre>
<p>profiling result</p>
<img src="https://www.victoryang00.cn/picture/image-20200206200505308.png" alt="graph" style="zoom:100%;" />
</li>
</ol>
<p>summary</p>
<img src="https://www.victoryang00.cn/picture/image-20200206200701826.png" alt="image-20200206200701826" style="zoom:50%;" />
<img src="https://www.victoryang00.cn/picture/image-20200206202701475.png" alt="graph" style="zoom:100%;" />
<p>the summary for profiling of both cpu and gpu, the most time is consumed on computing the real kernel which I think the computing power is fully utilized. </p>
<p>Accelerated percentage of single node over omp+mpi is 319.799/220.807=1.448319120317744‬‬</p>
<p>Accelerated percentage of single node over single gpu is 319.799/19.328=16.54627720533642</p>
<p>power consumption: over cpu:<img src="https://www.victoryang00.cn/picture/image-20200206203642478.png" alt="image-20200206203642478" style="zoom:25%;" /></p>
<p>​									over gpu: 111W on average</p>
<p>Our future plan: </p>
<ol>
<li>deploy the gpu code on multigpu using nccl.</li>
<li>solve the global memory store and load efficiency.</li>
</ol>
<h2 id="misc"><a class="header" href="#misc">misc</a></h2>
<p>Loves from Github</p>
<ol>
<li>https://github.com/QuEST-Kit/QuEST/issues/220
<img src="https://www.victoryang00.cn/picture/image-20200206203018990.png" alt="graph" style="zoom:100%;" /></li>
</ol>
<pre><code>Hi Jiachen,

There are no plans currently to combine distribution with GPU-acceleration. Note there are a few ways this can be done, and I suspect none really align with QuEST's design philosophy, nor are practical due to memory overheads. I've wanted to pen these thoughts for a while, so read on below if interested! :)

Firstly, QuEST uses its hardware to accelerate the simulation of a single quantum register at a time. While I think there are good uses of multi-GPU to speedup simultaneous simulation of multiple registers, this would be a totally new pattern to QuEST's simulation style. So let's consider using multi-GPU to accelerate a single register.

There are a few ways you can have &quot;multiple GPUs&quot;:

multiple NVlinked GPUs
This is when you have multiple GPUs tightly connected with a high-bandwidth fabric (e.g. this). The bandwidth is enough that you sort of can imagine it as a single big GPU, and hence it would be worthwhile for accelerating single-register simulation. However, this only exists right now as NVLink and NVSwitch, compatible only with IBM's POWER architecture - you could argue this is still esoteric, and not worth a big refactor. Note it wouldn't actually be very hard to refactor QuEST for this platform - indeed QuEST works out-of-the-box with POWER8. But it's not something on our TODO list currently.

multiple local GPUs
This is when you have multiple GPUs on the same machine, but maybe on different sockets and hence with a much lower bandwidth between them. The most common case is two GPUs - is it worthwhile using two GPUs over one to speedup single register simulation? Often, no!
In big QC simulation, having to move memory around is often the big killer, and should be avoided where possible. Unfortunately, simulating unitaries on registers often requires moving memory. If all the memory stays in the GPU (very high &quot;internal bandwidth&quot;), this is ok, but copying memory to the other GPU (across the socket) will introduce a huge per-gate overhead!
Hence, using two GPUs to simulate the same register size can be slower than using just one, especially as the simulation size grows and saturates the sockets!
There's hardly a benefit from the extra VRAM too, because doubling the memory enables simulation of one additional qubit. This is not worth the slowdown, or the hardware!
Even with more than two GPUs, the connections are likely hierarchical and so even more prone to saturation.

distributed GPUs
This is when you have a GPU(s) on each distributed node of a cluster. In this circumstance, simulating a unitary gate which requires data exchange not only costs us a VRAM to RAM overhead (similar to before), but a networking overhead to talk to the other nodes! This can be somewhat improved by having a direct GPU to network-card connection (and MPI abstraction), but I believe that's pretty cutting-edge.
Let's say you have n nodes, each with a GPU and a multicore CPU, and you're resolved to a distributed simulation. When is it worthwhile to pay the extra memory overhead locally copying from RAM to VRAM (and use the GPU), over using just the CPUs? This is now the same trade-off to consider in the previous cases. So may or may not be worthwhile.

TL-DR: besides the somewhat esoteric case of having multiple tightly-connected GPUs, multi-GPU simulation introduces a new memory overhead that doesn't exist in single-GPU simulation. This overhead is almost always way longer than the time the GPU spends simulating the gate. As to whether the whole simulation is sped up by the use of multi-GPU is system and simulation specific.
</code></pre>
<ol start="2">
<li>https://github.com/NVIDIA/nccl/pull/316
This is a PR for people to review and provide feedback on the p2p branch (issue <a href="https://github.com/NVIDIA/nccl/issues/212">#212</a>).</li>
</ol>
<pre><code>Looking forward to applying the P2P function to increase the power of my project!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="isc"><a class="header" href="#isc">ISC</a></h1>
<h2 id="奖项"><a class="header" href="#奖项">奖项</a></h2>
<ul>
<li>总冠军一名，授予在整体算例以及现场呈现过程中得分最高的队伍。</li>
<li>HPL单项冠军一名，授予HPL比赛成绩最高的队伍。</li>
<li>最受欢迎奖一名，授予比赛期间得到ISC13参会者投票最多的队伍。</li>
</ul>
<h2 id="命题"><a class="header" href="#命题">命题</a></h2>
<p>HPL等benchmark和其他4项应用以及一道神秘赛题。</p>
<div style="break-before: page; page-break-before: always;"></div><p>失败了</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id=""><a class="header" href="#"></a></h1>
<h2 id="autotuning-就是一个简单oi题"><a class="header" href="#autotuning-就是一个简单oi题">AutoTuning 就是一个简单OI题</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrf"><a class="header" href="#wrf">WRF</a></h1>
<blockquote>
<p>傻逼Fortran，2021年了，居然还有人用Fortran</p>
<p>最好找做气象的人问问有关参数设置的问题，可惜我没找到</p>
</blockquote>
<p>这是一个有关地球科学的天气模拟系统，所有有关地球科学和Fortran并行化的其他应用都可以参考一下</p>
<h2 id="task-links-and-introductions"><a class="header" href="#task-links-and-introductions">Task links and introductions</a></h2>
<p><a href="https://hpcadvisorycouncil.atlassian.net/wiki/spaces/HPCWORKS/pages/1827438600/WRF+with+Single+Domain+-+Practice+case+for+ISC21+SCC">Practice case for ISC21 SCC</a></p>
<p><a href="https://hpcadvisorycouncil.atlassian.net/wiki/spaces/HPCWORKS/pages/1827438607/WRF+-+3+Domain+Problem+for+ISC21+SCC">3 Domain Problem for ISC21 SCC</a></p>
<h2 id="install"><a class="header" href="#install">Install</a></h2>
<h3 id="required-libs"><a class="header" href="#required-libs">required libs</a></h3>
<p>HDF5, NetCDF-C, NetCDF-Fortran (手动安装可能更好，需要mpi)</p>
<h4 id="hdf5"><a class="header" href="#hdf5">HDF5</a></h4>
<pre><code class="language-bash">./configure --prefix=你的安装路径/hdf5 --enable-fortran --enable-fortran2003 --enable-parallel
make -j 48
make install
</code></pre>
<pre><code class="language-bash"># vi ~/.bashrc
export HDF5=你的安装路径/hdf5
export PATH=$HDF5/bin:$PATH
export LD_LIBRARY_PATH=$HDF5/lib:$LD_LIBRARY_PATH
export INCLUDE=$HDF5/include:$INCLUDE
# source ~/.bashrc
</code></pre>
<h4 id="netcdf-c"><a class="header" href="#netcdf-c">NetCDF-C</a></h4>
<pre><code class="language-bash">./configure --prefix=你的安装路径/netcdf LDFLAGS=&quot;-L$HDF5/lib&quot; CPPFLAGS=&quot;-I$HDF5/include&quot; CC=mpiicc --disable-dap
make -j 48
make install
</code></pre>
<pre><code class="language-bash"># vi ~/.bashrc
export NETCDF=/usr/local/netcdf
export PATH=$NETCDF/bin:$PATH
export LD_LIBRARY_PATH=$NETCDF/lib:$LD_LIBRARY_PATH
export INCLUDE=$NETCDF/include:$INCLUDE
# source ~/.bashrc
</code></pre>
<h4 id="netcdf-fortran"><a class="header" href="#netcdf-fortran">NetCDF-Fortran</a></h4>
<pre><code class="language-bash">./configure --prefix=你的安装路径/netcdf CPPFLAGS=&quot;-I$HDF5/include -I$NETCDF/include&quot; LDFLAGS=&quot;-L$HDF5/lib -L$NETCDF/lib&quot; CC=mpiicc FC=mpiif90 F77=mpiif90 # 与NetCDF-C安装在同一目录下
make -j 48
make install
</code></pre>
<h3 id="advanced-lib"><a class="header" href="#advanced-lib">Advanced lib</a></h3>
<p><a href="https://parallel-netcdf.github.io/">PNetCDF</a> A Parallel I/O Library for NetCDF File Access</p>
<blockquote>
<p>4个node有负面效果，需要8个node及以上才会和NertCDF有异</p>
</blockquote>
<p><a href="https://z3.ax1x.com/2021/07/15/WnELTI.md.png">pnetcdf.png</a></p>
<p>安装方法见官网</p>
<h3 id="main-program"><a class="header" href="#main-program">Main Program</a></h3>
<p>经过测试，使用intelMPI会出现segment fault，OpenMPI则不会，然而intelMPI好像并没有很多提高，可以从stack size的角度尝试修正这个问题。</p>
<h4 id="env-setting"><a class="header" href="#env-setting">env setting</a></h4>
<pre><code class="language-bash">intel openmpi hdf5 netcdf
</code></pre>
<h4 id="config-and-build"><a class="header" href="#config-and-build">config and build</a></h4>
<pre><code class="language-bash">./configure
</code></pre>
<pre><code class="language-bash">checking for perl5... no
checking for perl... found /usr/bin/perl (perl)
Will use NETCDF in dir: /global/software/centos-7.x86_64/modules/intel/2020.1.217/netcdf/4.7.4
HDF5 not set in environment. Will configure WRF for use without.
PHDF5 not set in environment. Will configure WRF for use without.
Will use 'time' to report timing information
$JASPERLIB or $JASPERINC not found in environment, configuring to build without grib2 I/O...
------------------------------------------------------------------------
Please select from among the following Linux x86_64 options:

  1. (serial)   2. (smpar)   3. (dmpar)   4. (dm+sm)   PGI (pgf90/gcc)
  5. (serial)   6. (smpar)   7. (dmpar)   8. (dm+sm)   PGI (pgf90/pgcc): SGI MPT
  9. (serial)  10. (smpar)  11. (dmpar)  12. (dm+sm)   PGI (pgf90/gcc): PGI accelerator
 13. (serial)  14. (smpar)  15. (dmpar)  16. (dm+sm)   INTEL (ifort/icc)
                                         17. (dm+sm)   INTEL (ifort/icc): Xeon Phi (MIC architecture)
 18. (serial)  19. (smpar)  20. (dmpar)  21. (dm+sm)   INTEL (ifort/icc): Xeon (SNB with AVX mods)
 22. (serial)  23. (smpar)  24. (dmpar)  25. (dm+sm)   INTEL (ifort/icc): SGI MPT
 26. (serial)  27. (smpar)  28. (dmpar)  29. (dm+sm)   INTEL (ifort/icc): IBM POE
 30. (serial)               31. (dmpar)                PATHSCALE (pathf90/pathcc)
 32. (serial)  33. (smpar)  34. (dmpar)  35. (dm+sm)   GNU (gfortran/gcc)
 36. (serial)  37. (smpar)  38. (dmpar)  39. (dm+sm)   IBM (xlf90_r/cc_r)
 40. (serial)  41. (smpar)  42. (dmpar)  43. (dm+sm)   PGI (ftn/gcc): Cray XC CLE
 44. (serial)  45. (smpar)  46. (dmpar)  47. (dm+sm)   CRAY CCE (ftn $(NOOMP)/cc): Cray XE and XC
 48. (serial)  49. (smpar)  50. (dmpar)  51. (dm+sm)   INTEL (ftn/icc): Cray XC
 52. (serial)  53. (smpar)  54. (dmpar)  55. (dm+sm)   PGI (pgf90/pgcc)
 56. (serial)  57. (smpar)  58. (dmpar)  59. (dm+sm)   PGI (pgf90/gcc): -f90=pgf90
 60. (serial)  61. (smpar)  62. (dmpar)  63. (dm+sm)   PGI (pgf90/pgcc): -f90=pgf90
 64. (serial)  65. (smpar)  66. (dmpar)  67. (dm+sm)   INTEL (ifort/icc): HSW/BDW
 68. (serial)  69. (smpar)  70. (dmpar)  71. (dm+sm)   INTEL (ifort/icc): KNL MIC
 72. (serial)  73. (smpar)  74. (dmpar)  75. (dm+sm)   FUJITSU (frtpx/fccpx): FX10/FX100 SPARC64 IXfx/Xlfx

Enter selection [1-75] :
</code></pre>
<p>dm+sm: OMP+MPI</p>
<pre><code class="language-bash">./compile -j 6 em_real &gt;&amp; build_wrf.log
tail -15 build_wrf.log
</code></pre>
<h4 id="finish"><a class="header" href="#finish">finish</a></h4>
<p>所有执行文件都在<code>run</code>文件夹中。</p>
<h2 id="run"><a class="header" href="#run">Run</a></h2>
<pre><code class="language-bash">for i in ../WRF/run/* ; do ln -sf $i $(数据所在目录) ; done
</code></pre>
<p><code>namelist.input</code>是输入文件，其中有众多参数需要设置，可以参考<a href="https://esrl.noaa.gov/gsd/wrfportal/namelist_input_options.html"><strong>WRF NAMELIST.INPUT FILE DESCRIPTION</strong></a>。</p>
<h3 id="slurm-script"><a class="header" href="#slurm-script">slurm script</a></h3>
<pre><code class="language-bash">#!/bin/bash -l
#SBATCH -N 4
#SBATCH --ntasks-per-node=20
#SBATCH --cpus-per-task=2
#SBATCH --ntasks=80
#SBATCH -J wrf3Dom_mpi_80_omp_2
#SBATCH -p compute
#SBATCH -t 2:00:00
#SBATCH -o wrf3Dom-%j.out
sleep 300
module load NiaEnv/2019b
module load intel/2019u4  openmpi/4.0.1
#hdf5/1.10.5
#module load netcdf/4.6.3

ulimit -c unlimited
ulimit -s unlimited

module list

export HDF5=/home/l/lcl_uotiscscc/lcl_uotiscsccs1034/scratch/nonspack/hdf5
export PATH=$HDF5/bin:$PATH
export LD_LIBRARY_PATH=$HDF5/lib:$LD_LIBRARY_PATH
export INCLUDE=$HDF5/include:$INCLUDE

export NETCDF=/home/l/lcl_uotiscscc/lcl_uotiscsccs1034/scratch/nonspack/netcdf
export PATH=$NETCDF/bin:$PATH
export LD_LIBRARY_PATH=$NETCDF/lib:$LD_LIBRARY_PATH
export INCLUDE=$NETCDF/include:$INCLUDE


export KMP_STACKSIZE=20480000000


export OMP_NUM_THREADS=$SLURM_CPUS_PER_TASK
cd ~/scratch/pl/orifiles
mpirun -np 80 -cpus-per-rank $SLURM_CPUS_PER_TASK ./wrf.exe
</code></pre>
<h2 id="important-notice"><a class="header" href="#important-notice">Important Notice</a></h2>
<h3 id="stack-size-and-segment-fault"><a class="header" href="#stack-size-and-segment-fault"><code>stack size</code> and <code>segment fault</code></a></h3>
<p><code>ulimit</code> sets the OS limits for the program.
<code>KMP_STACKSIZE</code> tells the OpenMP implementation about how much stack to actually allocate for each of the stacks. So, depending on your OS defaults you might need both. BTW, you should rather use <code>OMP_STACKSIZE</code> instead, as <code>KMP_STACKSIZE</code> is the environment variable used by the Intel and clang compilers. <code>OMP_STACKSIZE</code> is the standard way of setting the stack size of the OpenMP threads.
Note, that this problem is usually more exposed, as Fortran tends to keep more data on the stack, esp. arrays. Some compilers can move such arrays to the heap automatically, see for instance <code>-heap-arrays</code> for the Intel compiler.</p>
<p>Fortran的OMP进程会在stack里塞一大堆东西，很多时候会爆栈，所以使用Fortran和OMP的应用需要注意<code>export KMP_STACKSIZE=20480000000</code>, 而且<code>gcc</code>是<code>OMP</code>,<code>icc</code>是<code>KMP</code>。</p>
<h3 id="fortran-and-mpi"><a class="header" href="#fortran-and-mpi">Fortran and MPI</a></h3>
<p>不知道是slurm还是Fortran的问题，slurm不能对Fortran的MPI程序自动分配CPU核心，所以需要手动设置，</p>
<pre><code class="language-bash">mpirun -np 16 -cpus-per-rank $SLURM_CPUS_PER_TASK ./wrf.exe
</code></pre>
<p>tell mpi how many cpu cores should one mpi rank get for openmp</p>
<h3 id="ipm-report-env-setting"><a class="header" href="#ipm-report-env-setting">IPM Report env setting</a></h3>
<p>IPM是一个监控MPI使用的profiler。使用IPM只需要perloadIPM的lib就可以了。但是为了完整生成报告图片，需要设定以下变量</p>
<pre><code class="language-bash">export IPM_REPORT=full
export IPM_LOG=full
</code></pre>
<p>When using IPM, set above envs to make sure you can get right xml to visualize, or using https://files.slack.com/files-pri/TAXMW9014-F02586VN27L/download/ipm.ipynb to visualize</p>
<h2 id="others"><a class="header" href="#others">Others</a></h2>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="benchmark"><a class="header" href="#benchmark">Benchmark</a></h1>
<p>这里放置HPC竞赛中Benchmark有关资料。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- TITLE: Hpcg Dat -->
<!-- SUBTITLE: A quick summary of Hpcg Dat -->
<h1 id="dat-specs"><a class="header" href="#dat-specs">.dat Specs</a></h1>
<h2 id="asc20"><a class="header" href="#asc20">ASC20</a></h2>
<pre><code>HPCG benchmark input file
Sandia National Laboratories; University of Tennessee, Knoxville
384 256 256
60
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- TITLE: HPL hpl.dat Config -->
<!-- SUBTITLE: Ancestral hpl.dat config file -->
<h1 id="hpl-dat-config-file"><a class="header" href="#hpl-dat-config-file">HPL .dat config file</a></h1>
<h2 id="asc18"><a class="header" href="#asc18">ASC18</a></h2>
<p>The following is the HPL <code>.dat</code> configuration file template from ASC18.</p>
<pre><code>HPLinpack benchmark input file
Innovative Computing Laboratory, University of Tennessee
HPL.out      output file name (if any)
6            device out (6=stdout,7=stderr,file)
1            # of problems sizes (N)
67200 65280 62976 65280 96000 65280 38400 96000 102400 168960 153600 76800   142848 153600 142848 124416 96256 142848 124416 115200 110592 96256 Ns
1             # of NBs
384 768 384 768 1024 768 896 768 1024 512 384 640 768 896 960 1024 1152 1280 384 640 960 768 640 256  960 512 768 1152         NBs
0            PMAP process mapping (0=Row-,1=Column-major)
1            # of process grids (P x Q)
2 1 2 1        Ps
1 2 2 4        Qs
16.0         threshold
1            # of panel fact
0 1 2        PFACTs (0=left, 1=Crout, 2=Right)
1            # of recursive stopping criterium
2 8          NBMINs (&gt;= 1)
1            # of panels in recursion
2            NDIVs
1            # of recursive panel fact.
0 1 2        RFACTs (0=left, 1=Crout, 2=Right)
1            # of broadcast
2 0 2          BCASTs (0=1rg,1=1rM,2=2rg,3=2rM,4=Lng,5=LnM)
1            # of lookahead depth
0            DEPTHs (&gt;=0)
1            SWAP (0=bin-exch,1=long,2=mix)
192          swapping threshold
1            L1 in (0=transposed,1=no-transposed) form
0            U  in (0=transposed,1=no-transposed) form
1            Equilibration (0=no,1=yes)
8            memory alignment in double (&gt; 0)
</code></pre>
<h2 id="asc20-1"><a class="header" href="#asc20-1">ASC20</a></h2>
<p>The following is the HPL <code>.dat</code> configuration file template from ASC20.
Machine Spec : 8 Tesla V100</p>
<pre><code>HPLinpack benchmark input file
Innovative Computing Laboratory, University of Tennessee
HPL.out      output file name (if any)
6            device out (6=stdout,7=stderr,file)
2            # of problems sizes (N)
175104 178176 165888 168960 172032 175104 Ns
2             # of NBs
384 256 128 256 384 192 288 320 384 384 768 1024 768 896 768 1024 512 384 640 768 896 960 1024 1152 1280 384 640 960 768 640 256  960 512 768 1152         NBs
0            PMAP process mapping (0=Row-,1=Column-major)
1            # of process grids (P x Q)
4 2 8 1 2 1        Ps
4 8 2 2 4        Qs
16.0         threshold
1            # of panel fact
0 1 2        PFACTs (0=left, 1=Crout, 2=Right)
1            # of recursive stopping criterium
2 8          NBMINs (&gt;= 1)
1            # of panels in recursion
2            NDIVs
1            # of recursive panel fact.
0 1 2        RFACTs (0=left, 1=Crout, 2=Right)
1            # of broadcast
2 0 2          BCASTs (0=1rg,1=1rM,2=2rg,3=2rM,4=Lng,5=LnM)
1            # of lookahead depth
0            DEPTHs (&gt;=0)
1            SWAP (0=bin-exch,1=long,2=mix)
192          swapping threshold
1            L1 in (0=transposed,1=no-transposed) form
0            U  in (0=transposed,1=no-transposed) form
1            Equilibration (0=no,1=yes)
8            memory alignment in double (&gt; 0)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="devops"><a class="header" href="#devops">DevOps</a></h1>
<p>这里放置有关HPC环境维护有关的资料。</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="salt-stack"><a class="header" href="#salt-stack">Salt Stack</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pbs-1"><a class="header" href="#pbs-1">PBS</a></h1>
<h1 id="slurm"><a class="header" href="#slurm">Slurm</a></h1>
<p>本超算使用的是</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="singularity"><a class="header" href="#singularity">Singularity</a></h1>
<p>伯克利出品的一个用户态放 docker 的地方。</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="chisel"><a class="header" href="#chisel">Chisel</a></h1>
<p>有关我们是否有必要学习一门逻辑电路描述语言去实现一个 CPU 或者一个路由器？ 我认为是十分必要的，这让大家可以从底往上看你的 Data 和 Instruction 的变动。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="go"><a class="header" href="#go">Go</a></h1>
<p>此语言是个非常简单上手的语言，同时由于大厂使用过多，市面上开源的工具都非常可用。笔者在实习的时候学习的，<code>module</code> 等包管理工具在并行文件系统上面的 <code>channel</code> + <code>context</code> 重新实现非常快，那个代码也就数十行处理一些并行质询的状态机即可，也用其写过一些 eBPF 的代码用于更好的获得文件 IO 的实时性能。</p>
<h2 id="一些小工具"><a class="header" href="#一些小工具">一些小工具</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<p>Rust 是好活，自从我校2016年以 Rust 语言开设 CS100（程序语言设计）开始，上科大就成为了宣传Rust的堡垒，中国 Rust 之父张汉东先生及宣发 Rust 的各界人士选择推广 Rust 的最佳地点就会选择上科大，这雨与 riscv 类似。写小的bash工具（ Zero Cost Abstraction 的 cffi ）、写大型（10w+ line）的系统方向程序必备。由于语言特性有很多的静态检查，会指导大家对于内存管理，异步编程有更深刻的理解。</p>
<h2 id="学习参考资料"><a class="header" href="#学习参考资料">学习参考资料</a></h2>
<ol>
<li>rCore - 清华维护的教学操作系统</li>
<li>Libra - 脸书维护的区块链数据库</li>
<li>飞书 - Tokio 代码池</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libs"><a class="header" href="#libs">Libs</a></h1>
<p>这里放置一些常用库的安装和使用事项。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boost"><a class="header" href="#boost">Boost</a></h1>
<p><a href="https://www.boost.org/">website</a></p>
<h2 id="spack"><a class="header" href="#spack">Spack</a></h2>
<pre><code class="language-bash">spack info boost
spack install boost
</code></pre>
<h2 id="source"><a class="header" href="#source">Source</a></h2>
<pre><code class="language-bash">./bootstrap.sh --help
# Select your configuration options and invoke ./bootstrap.sh again without the --help option. Unless you have write permission in your system's /usr/local/ directory, you'll probably want to at least use

./bootstrap.sh --prefix=path/to/installation/prefix
# to install somewhere else. Also, consider using the --show-libraries and --with-libraries=library-name-list options to limit the long wait you'll experience if you build everything. Finally,

./b2 install
# will leave Boost binaries in the lib/ subdirectory of your installation prefix. You will also find a copy of the Boost headers in the include/ subdirectory of the installation prefix, so you can henceforth use that directory as an #include path in place of the Boost root directory.

# and add to PATH and LD and INCLUDE
</code></pre>
<h2 id="版本相关问题"><a class="header" href="#版本相关问题">版本相关问题</a></h2>
<p>This is Version 3 of the Filesystem library. Version 2 is not longer supported. 1.49.0 was the last release of Boost to supply Version 2。</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="armforge"><a class="header" href="#armforge">ArmForge</a></h1>
<p><a href="https://www.arm.com">Arm</a> Forge 是一个 Arm 公司出品的对高性能程序的软件。最强大的地方就是他对 CPU GPU 都非常适用，包括 Arm DDT 和 Arm MAP 的工具。Arm DDT 是业界领先的并行调试器，支持 MPI、CUDA 和 OpenMP。Arm MAP是用于MPI、OpenMP和 Vectorized 程序的低开销线级剖析器。</p>
<ul>
<li><a href="https://www.Arm.com/products/forge/download">下载 Arm Forge（DDT + MAP）</a>，已使用 spack 部署</li>
<li><a href="https://developer.arm.com/docs/101136/latest/arm-forge/introduction">Arm Forge用户指南</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uprof"><a class="header" href="#uprof">uProf</a></h1>
<p>AMD 出品的一款 perf 工具，增加了一些 X86 超集的 metrics，但 UI 比较丑。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vtune"><a class="header" href="#vtune">Vtune</a></h1>
<p>都说做体系结构的人最懂做 Profiling，一个好的 Profiling 工具一定是有好的对 CPU 实时性能的抽象，最简单的命令是 <code>rdstc</code>， arm上也有类似的实现</p>
<h2 id="abi-支持"><a class="header" href="#abi-支持">ABI 支持</a></h2>
<p>profiler 需要有对 Intel Proceccor 各种 metrics 的函数实现，在安装Vtune的过程中会编译对当前系统的 <a href="https://software.intel.com/content/www/us/en/develop/articles/intel-performance-counter-monitor.html">PMU</a> 的动态链接库，意为对 Intel <a href="https://software.intel.com/content/www/us/en/develop/articles/intel-performance-counter-monitor.html">PMU</a> 的 ABI支持，我队使用的 epyc 有epyc适用的魔改版 <a href="https://github.com/AMDESE/amd-perf-tools">PMU Tools</a>。现在体系结构安全界学术主流对 PMU 的研究很深，因为其泄露了部分对 CPU 实时的状态，可以从中获取想要的东西。</p>
<p>X86 需要支持的 perf 参数比较有限，linux从kprobe，uprobe这些官方支持的 microprocessor sampling有很有用的，这些已被eBPF所采用。</p>
<p>Intel Compiler 在编译 broadwell 以上架构优化时主要做了三件对性能影响很大的事情：</p>
<ol>
<li>激进的跨 basic block 优化 + Vectorization + Loop Unroll</li>
<li>Load 和 Store 在满足 TSO 条件下的激进的重排，同时激进的整合数据，支持 store buffer bypass，movnt。同时也是 icc 后端 Bug 的主要来源。也是大厂不太实用他的原因。除 HPC 外，大家一般照 gcc 标准。</li>
<li>自己维护的 TBB 线程池（非常快），自己维护的 malloc_align，自己维护的相关库。</li>
</ol>
<p>有关如何更好的适配 Intel 的CPU，可以参考 Lammps 的 <a href="https://t.co/6DUtP6Falq?amp=1">Intel Package</a>。其使用访问者模式对 Intel processor的寄存器资源。</p>
<p>有关对用户态文件系统的适配，Vtune 提供了对 PM 带宽的实时测试，这个 metrics 貌似很难拿到。</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><!-- TITLE: Cluster Setup -->
<!-- SUBTITLE: Cluster setup procedure -->
<h1 id="cluster-setup-流程"><a class="header" href="#cluster-setup-流程">Cluster Setup 流程</a></h1>
<p>完整流程 &amp; 踩坑笔录</p>
<h2 id="机器信息--硬件准备"><a class="header" href="#机器信息--硬件准备">机器信息 &amp; 硬件准备</a></h2>
<ul>
<li>节点：4 节点 （node1~4，node1 为 <em>主节点</em>）</li>
<li>网络：Ethernet（<code>192.168.&lt;A&gt;.x</code>）与 IB（<code>192.168.&lt;B&gt;.x</code>）
<ul>
<li>星状拓扑</li>
<li>Setup 时主节点需连接外网</li>
</ul>
</li>
<li>硬盘：每个节点一块系统盘，主节点额外挂一块 SSD 作为共享存储</li>
<li>Clonezilla 镜像 U 盘 * 1（镜像直接解压即可，故下述安装时需要 BIOS 设置为 UEFI 模式）</li>
<li>Clean Minimal CentOS7 镜像 U 盘 * 1（同上）</li>
</ul>
<h2 id="centos-操作系统安装"><a class="header" href="#centos-操作系统安装">CentOS 操作系统安装</a></h2>
<p>下载 <strong>CentOS-7 Minimal 镜像</strong> 于 U 盘，插于主节点</p>
<blockquote>
<p>如果主板 BIOS 启动模式不是 UEFI 则勿忘在启动时修改 ;(
主节点需要使用外置 Clonezilla 镜像 U 盘，故也把 U 盘启动顺序置前</p>
</blockquote>
<p>主节点开机 “install CentOS 7”</p>
<blockquote>
<p>如果 Install 后触发了 <code>dracut-init... timeout</code>，在之后会跳入 <code>dracut</code> 命令行，输入 <code>lsblk</code> 后找到 U 盘设备，记下 <code>LABEL=AAA</code> 的值，而后 <code>reboot</code>；然后在选择界面按 <code>e</code>，修改第二行中的 <code>LABEL=BBB</code> 的第一段 为 <code>AAA</code>，然后 <code>ctrl+x</code> 即可
另一种方法是将LABEL=CentOS\x207\x20x\86_64修改为LABEL=CentOS\x207\x20x\8
https://blog.csdn.net/qq_36937234/article/details/82996998
https://access.redhat.com/solutions/2515741</p>
</blockquote>
<p>需调整项如下：</p>
<ul>
<li>磁盘分区 <code>/</code> + <code>/boot</code> 即可，根目录各子目录不分散分区，格为ext4</li>
<li>主机名 Hostname 设为 <code>node1</code></li>
</ul>
<p>待安装完成，以 <code>root</code> 用户可正常登陆</p>
<p><strong>关闭 SELinux</strong>：修改 <code>/etc/selinux/config</code>，设置 <code>SELINUX=disabled</code></p>
<p><strong>关闭 Firewall 防火墙</strong>：</p>
<pre><code class="language-bash">systemctl stop firewalld.service
systemctl disable firewalld.service
</code></pre>
<blockquote>
<p>很多问题都会由上述两个安全服务引起，在超算比赛内网环境下无用，先全关闭</p>
</blockquote>
<h2 id="以太网连接配置"><a class="header" href="#以太网连接配置">以太网连接配置</a></h2>
<p>先配置主节点连接外网，再将各节点内网连接</p>
<h3 id="ethernet-外网"><a class="header" href="#ethernet-外网">Ethernet 外网</a></h3>
<p>连接外网以太网线（记住对应网口 <code>&lt;INTERFACE&gt;</code>，e.g. <code>eno2</code>）</p>
<p>使用 <code>ip</code> 指令检查 DNS 地址等信息，而后在输入 <code>nmtui</code> 进入 GUI 网络设置界面，设置外网连接为 DHCP 模式，填入 
DNS 服务器地址，而后使用 <code>curl</code> 进行校网登录：</p>
<pre><code class="language-bash">$ dhclient -v &lt;INTERFACE&gt;
$ curl -X POST --data “userName=&lt;USERNAME&gt;&amp;password=&lt;PASSWD&gt;&amp;hasValidateCode=false&amp;authLan=zh_CN” https://10.15.44.172:8445/PortalServer//Webauth/webAuthAction\!login.action
</code></pre>
<p>此时可以连接外网，需要记录下本机 ip 地址以便远程连接（校网中途不关机则 DHCP ip 地址应该不会改变）；<code>curl &lt;URL&gt;</code> 检查外网连接</p>
<h3 id="ethernet-内网"><a class="header" href="#ethernet-内网">Ethernet 内网</a></h3>
<p>同样使用 <code>ip</code> 工具看到网关地址等信息，使用 <code>nmtui</code> GUI 工具对内网网口（e.g. <code>eno1</code>）进行配置，e.g. 主节点 <code>192.168.&lt;A&gt;.1</code></p>
<h2 id="驱动下载--安装"><a class="header" href="#驱动下载--安装">驱动下载 &amp; 安装</a></h2>
<p>IB 驱动 &amp; Nvidia 驱动，安装在默认位置（因为共享盘还未配置），故在拷盘前做好</p>
<h3 id="ib-驱动和配置"><a class="header" href="#ib-驱动和配置">IB 驱动和配置</a></h3>
<p><a href="https://blog.csdn.net/oPrinceme/article/details/51001849">IB 驱动</a></p>
<h3 id="nvidia-驱动"><a class="header" href="#nvidia-驱动">Nvidia 驱动</a></h3>
<p><code>yum install kernel-dev epel-release dkms</code> 来添加 <code>Redhat</code> 源 及 其他 Nvidia 驱动依赖</p>
<p>关闭默认 <code>nouveau</code> 显卡驱动：</p>
<pre><code class="language-bash">$ vi /etc/default/grub    # `GRUB_CMDLINE_LINUX` 选项中添加 `nouveau.modeset=0`
$ grub2-mkconfig -o /boot/efi/EFI/centos/grub.cfg
$ reboot
</code></pre>
<blockquote>
<p>不要用官网的 rpm 包安装驱动 ;(</p>
</blockquote>
<p>重启后，在官网查询所用卡对应的最新驱动版本 <code>&lt;VER.SUB&gt;</code>（e.g. V100 目前最新为 <code>410.79</code>），获取安装脚本并安装：</p>
<pre><code class="language-bash">$ wget http://us.download.nvidia.com/XFree86/Linux-x86_64/&lt;VER.SUB&gt;/NVIDIA-Linux-x86_64-&lt;VER.SUB&gt;.run
$ bash NVIDIA-Linux-x86_64-&lt;VER.SUB&gt;.run --kernel-source-path /usr/src/kernels/xxx    # 若报错加此选项安装试试
</code></pre>
<p>试 <code>nvidia-smi</code> 指令看能否获取到显卡信息</p>
<h2 id="克隆创建子节点"><a class="header" href="#克隆创建子节点">克隆创建子节点</a></h2>
<p>先安装必要的基本工具以减少重复工作：<code>yum -y install &lt;TOOL-NAME&gt;</code>：</p>
<ul>
<li>NFS：<code>nfs-utils rpcbind</code></li>
<li>Lmod：<code>environment-modules</code></li>
<li>其他：<code>gcc gcc-c++ perl wget</code>（通过 <code>yum</code> 预安装 gcc 用于并行库工具等的编译安装）</li>
</ul>
<p>主节点关机，插入 <em>Clonezilla</em> 工具盘，从它启动，将主节点系统盘克隆至子节点系统盘内（勿搞错拷贝 Source &amp; Target 盘方向）：<a href="https://www.tecmint.com/linux-centos-ubuntu-disk-cloning-backup-using-clonezilla">https://www.tecmint.com/linux-centos-ubuntu-disk-cloning-backup-using-clonezilla</a></p>
<p>子节点插入系统盘后，分别登陆各子节点，修改主机名和静态 ip 地址（内网网口），以便互联识别身份，注意 <strong>4 节点 ip 和 主机名 互不相同</strong>：</p>
<pre><code class="language-bash"># e.g. node2 节点
$ hostnamectl set-hostname node2
$ vi /etc/sysconfig/network-scripts/ifcfg-&lt;INTERFACE&gt;   #修改 IPADDR=192.168.&lt;A&gt;.2
</code></pre>
<h2 id="数据盘-nfs-共享over-ib-rdma"><a class="header" href="#数据盘-nfs-共享over-ib-rdma">数据盘 NFS 共享（over IB RDMA）</a></h2>
<p><a href="https://developer.nvidia.com/blog/doubling-network-file-system-performance-with-rdma-enabled-networking/">howto-configure-nfs-over-rdma--roce-x</a></p>
<p>Maybe useful according to teacher Zhang</p>
<pre><code>opensmd
openibd
</code></pre>
<h2 id="数据盘-nfs-共享over-tcp备选"><a class="header" href="#数据盘-nfs-共享over-tcp备选">数据盘 NFS 共享（over TCP）备选</a></h2>
<p>主节点插上用作共享盘的硬盘，<code>lsblk</code> 查看新硬盘已插上及名称，可看到出现 e.g. <code>sdb1</code> 盘（根据大小判断那个为共享盘，勿搞错）</p>
<blockquote>
<p>格式化磁盘流程备忘：</p>
<p><code>$ fdisk /dev/sdb1</code>
<code>$     n                     # 新建分区</code>
<code>$     p 1 [Enter] [Enter]   # 整个盘建立为一个大主分区</code></p>
</blockquote>
<p>挂载该磁盘并在其中建立欲共享的目录（<code>/home</code> 和 <code>/opt</code>）:</p>
<pre><code class="language-bash">$ mount /dev/nvme0n1 /mnt/nfs
$ mkdir /mnt/nfs/home
$ mkdir /mnt/nfs/opt
</code></pre>
<p>主节点启动 NFS server，编辑共享目录配置 <code>/etc/exports</code>，添加条目（<em>注意不多加空格</em>）：</p>
<pre><code>/mnt/nfs/home 192.168.&lt;A&gt;.0/24(rw,no_root_squash,no_all_squash,sync)
/mnt/nfs/opt  192.168.&lt;A&gt;.0/24(rw,no_root_squash,no_all_squash,sync)
</code></pre>
<p>参数解释：</p>
<ul>
<li><code>rw</code>：可读写</li>
<li><code>no_*_squash</code>：客户节点以 * 身份使用时不降级为匿名普通用户</li>
<li><code>sync</code>：各端的写操作同步至磁盘</li>
</ul>
<p>开启服务并设置开机自启：</p>
<pre><code class="language-bash">$ exportfs -r
$ service rpcbind start
$ service nfs start
$ chkconfig rpcbind on
$ chkconfig nfs on
</code></pre>
<p>设置主节点防火墙允许 NFS 访问请求：</p>
<pre><code class="language-bash">$ firewall-cmd --permanent --add-service=mountd
$ firewall-cmd --permanent --add-service=nfs
$ firewall-cmd --permanent --add-service=rpc-bind
$ firewall-cmd --reload
</code></pre>
<p>修改 <code>/etc/fstab</code>，使主节点将共享目录 <em>bind mount</em> （目录树到目录树挂载） 到 <code>/home</code> <code>/opt</code>，子节点由 NFS 将主节点目录挂载：</p>
<pre><code># On node1，在 /etc/fstab 文件末尾添加
/dev/nvme0n1    /mnt/nfs    ext4    rw,user,exec,suid,dev,auto,async
/mnt/nfs/home   /home       none    rw,user,exec,suid,dev,auto,async,bind
/mnt/nfs/opt    /opt        none    rw,user,exec,suid,dev,auto,async,bind

# On node2~4，在 /etc/fstab 文件末尾添加
node1:/mnt/nfs/home    /home   nfs     rw,user,exec,suid,dev,auto,async
node1:/mnt/nfs/home    /opt    nfs     rw,user,exec,suid,dev,auto,async
</code></pre>
<p>而后每次开机后，各节点均登入 root 用户，<strong>先在主节点</strong> <code>mount -a</code>，<strong>后在各子节点</strong> <code>mount -a</code> 即可成功挂载共享目录</p>
<blockquote>
<p>全手动挂载方式备忘，开机后首先在主节点：</p>
<p><code>$ mount /dev/nvme0n1 /mnt/nfs</code>
<code>$ mount --bind /mnt/nfs/home /home</code>
<code>$ mount --bind /mnt/nfs/opt /opt</code></p>
<p>而后在各子节点：</p>
<p><code>$ showmount -e node1     # 检测是否有来自主节点的 nfs 共享</code>
<code>$ mount -t nfs node1:/mnt/nfs/home /home</code>
<code>$ mount -t nfs node1:/mnt/nfs/opt  /opt</code></p>
</blockquote>
<blockquote>
<p>出现 “Stale file handle” 问题 / “Access denied” 问题，在主节点重启 NFS：<code>systemctl restart nfs</code> 后再挂载一遍即可</p>
</blockquote>
<h2 id="ssh-免密码登录配置"><a class="header" href="#ssh-免密码登录配置">SSH 免密码登录配置</a></h2>
<p>首先配置 root 用户相互 <em>ssh</em> 免密登陆，<strong>所有节点对之间均需配置</strong>，e.g. 在主节点 <code>/root</code> 下：</p>
<pre><code class="language-bash">$ ssh-keygen            # 位置名称默认
$ ssh-copy-id node1    # 自身节点也需拷贝
$ ...
$ ssh-copy-id node4
</code></pre>
<p>而后在各自节点 <em>均</em> 创建普通用户，注意 <strong>相同名称</strong> &amp; <strong>相同 uid</strong> &amp; <strong>相同 group (gid)</strong> &amp; <strong>相同密码</strong>：</p>
<pre><code class="language-bash">$ useradd &lt;USERNAME&gt; -m
$ passwd &lt;USERNAME&gt;
$     [Type new PASSWORD] [Type again]    # 设置密码，不要通过 useradd 的 -p 选项，密码不规范时会失败
</code></pre>
<blockquote>
<p>密码通过 <code>passwd</code> 指令设置，否则密码不规范时 <code>-p</code> 选项可能失败且不会给出提示
按相同顺序创建即是，可以通过 <code>cat /etc/passwd</code> 检查</p>
</blockquote>
<p>任意节点进入普通用户，生成并拷贝密钥（注意普通用户 Home 目录共享）：</p>
<pre><code class="language-bash">$ su testuser
$ cd
$ ssh-keygen
      [Enter] [Enter] [Enter]
$ ssh-copy-id localhost
</code></pre>
<h2 id="编译器并行库和环境的安装"><a class="header" href="#编译器并行库和环境的安装">编译器、并行库和环境的安装</a></h2>
<p>环境安装目录文件树放置于 <code>/opt</code> 下</p>
<blockquote>
<p>所需环境及安装流程 - 见 “<a href="Sysadmin/environment-installation.html">Environment Installation</a>”</p>
</blockquote>
<h2 id="环境-environment-modules-配置"><a class="header" href="#环境-environment-modules-配置">环境 Environment Modules 配置</a></h2>
<p>前面已下载过 Lmod 工具；共享盘中 <code>mkdir /opt/modulefiles</code> 作为 modulefile 存储位置，而后在 <strong>每个</strong> 节点固定 modulefile 搜索路径，于 <code>/etc/environment</code> 中添加行：</p>
<pre><code class="language-bash">export MODULEPATH=/opt/modulefiles
</code></pre>
<blockquote>
<p>勿忘 <code>source /etc/environment</code></p>
</blockquote>
<blockquote>
<p>曾用 modulefile 文件 - 见 “<a href="Sysadmin/environment-modules.html">Modulefile Records</a>”</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><!-- TITLE: Environment Installation -->
<!-- SUBTITLE: Installation records for environment dependencies -->
<h1 id="环境安装记录"><a class="header" href="#环境安装记录">环境安装记录</a></h1>
<p>环境安装方式 + 目录树位置</p>
<h2 id="安装目录树结构"><a class="header" href="#安装目录树结构">安装目录树结构</a></h2>
<pre><code>|- /opt/
    |- openmpi/
        |- 4.0
        |- 3.1
        |- ...
    |- mpich/
    |- intel/    # Intel 全家福
    |- blas/
    |- gcc/
    |- cuda/     # Nvidia CUDA
    |- pgi/      # CUDA PGi Edition
    |- netcdf/
        |- netcdf-c/
        |- netcdf-fort/
    |- pnetcdf
</code></pre>
<blockquote>
<p>编译安装基本六连：</p>
<p><code>$ wget [SOURCE_URL]</code>
<code>$ tar zxvf openmpi-4.0.0.tar.gz</code>
<code>$ cd openmpi-4.0.0/</code>
<code>$ ./configure --prefix=‘/opt/mpi/openmpi/4.0’   # 注意规划好位置</code>
<code>$ make -j8</code>
<code>$ make install</code></p>
</blockquote>
<h2 id="包管理系统"><a class="header" href="#包管理系统">包管理系统</a></h2>
<blockquote>
<p><a href="https://spack.io/">spack</a>
Environment Modules
二选一， <code>spack</code> 基本上就是对系统级的<code>modules</code>的高层API，从ASC20开始，我们开始使用<code>spack</code>。为保证目录树nfs共享结构，把<code>spack</code> 放在/opt 目录下。</p>
</blockquote>
<blockquote>
<p>$ git clone https://github.com/spack/spack.git
$ cd spack/bin
$ ./spack install libelf # test
$ echo &quot;export PATH=$PATH:/opt/spack/bin&quot; &gt;&gt; ~/.bashrc
$ echo &quot;. /opt/spack/share/spack/setup-env.sh&quot; &gt;&gt; ~/.bashrc
$ bash</p>
</blockquote>
<p>依赖以及版本spec</p>
<blockquote>
<p>$ spack install intel^gcc@9</p>
</blockquote>
<p>在测试时使用</p>
<blockquote>
<p>$ spack load intel^gcc@9
也可以<code>module avail</code> 后查看需要load 的环境<code>module load intel</code></p>
</blockquote>
<p>添加新的编译器，在自己编译安装好一个编译器并在<code>PATH</code>中可以找到的时候，可以使用<code>spack find</code>命令，之后就可以用这个编译器<code>@intel</code>来编译新的编译器了。</p>
<p>特殊注意，在编译安装<code>mpi</code>,<code>omp</code>过程中一定要开启 --with-rdma 选项以支持Infiniband.</p>
<h2 id="编译器"><a class="header" href="#编译器">编译器</a></h2>
<ol>
<li><strong>gcc</strong> (包含 <strong>gfortran</strong>) - Version 7.4 + 5.5 + 4.9.4 + 4.4.7
<ul>
<li><code>CentOS</code> 自带的gcc版本过老，可以使用 <code>scl enable devtoolset-9 bash</code>以支持最新gcc特性。</li>
<li>7.4：<a href="http://ftp.gnu.org/gnu/gcc/gcc-7.4.0/gcc-7.4.0.tar.gz">gcc-7.4.0.tar.gz</a></li>
<li>5.5：<a href="http://ftp.gnu.org/gnu/gcc/gcc-5.5.0/gcc-5.5.0.tar.gz">gcc-5.5.0.tar.gz</a></li>
<li>4.4.7：<a href="http://ftp.gnu.org/gnu/gcc/gcc-4.4.7/gcc-4.4.7.tar.gz">gcc-4.4.7.tar.gz</a></li>
</ul>
</li>
<li><strong>icc</strong> &amp; <strong>ifort</strong>：包含于 <em>Intel Parallel Studio XE</em> 中</li>
</ol>
<h2 id="intel-parallel-studio-xe-全家桶"><a class="header" href="#intel-parallel-studio-xe-全家桶">Intel Parallel Studio XE 全家桶</a></h2>
<p><strong>Parallel Studio XE</strong>：按照 <a href="https://www.slothparadise.com/how-to-setup-the-intel-compilers-on-a-cluster">This Procedure</a> 获取和安装，19-20 授权如下</p>
<ul>
<li>序列号 S4ZD-MMZJXJ96 (若失效，可以前往英特尔官网申请，在下方register center，若为spack 安装只需在安装过程中输入即可)</li>
<li>URL：<a href="http://registrationcenter-download.intel.com/akdlm/irc_nas/tec/15088/parallel_studio_xe_2019_update2_cluster_edition.tgz">parallel_studio_xe_2019_update2_cluster_edition.tgz</a></li>
<li>LICENSE：官网 Registration Center 下载后传至 Server</li>
</ul>
<blockquote>
<p><code>icc</code> <code>ifort</code> <code>mkl</code> <code>IntelMPI</code> 均包含于 Parallel Studio XE 中
<code>spack install intel</code></p>
</blockquote>
<p>由于cuda只支持编译它的编译器头文件在gcc-7标准以前，所以建议使用intel@18.0.3</p>
<h2 id="mpi"><a class="header" href="#mpi">MPI</a></h2>
<ol>
<li><strong>OpenMPI</strong> - Version 4.0 + 3.1 + 3.0 + 2.1
<ul>
<li>4.0：<a href="https://download.open-mpi.org/release/open-mpi/v4.0/openmpi-4.0.0.tar.gz">openmpi-4.0.0.tar.gz</a></li>
<li>3.1：<a href="https://download.open-mpi.org/release/open-mpi/v3.1/openmpi-3.1.3.tar.gz">openmpi-3.1.3.tar.gz</a></li>
<li>3.0：<a href="https://download.open-mpi.org/release/open-mpi/v3.0/openmpi-3.0.3.tar.gz">openmpi-3.0.3.tar.gz</a></li>
<li>2.1：<a href="https://download.open-mpi.org/release/open-mpi/v2.1/openmpi-2.1.6.tar.gz">openmpi-2.1.6.tar.gz</a></li>
</ul>
</li>
<li><strong>MPICH</strong> - Version 3.3 + 3.2.1
<ul>
<li>3.3：<a href="http://www.mpich.org/static/downloads/3.3/mpich-3.3.tar.gz">mpich-3.3.tar.gz</a></li>
<li>3.2.1：<a href="http://www.mpich.org/static/downloads/3.2.1/mpich-3.2.1.tar.gz">mpich-3.2.1.tar.gz</a></li>
</ul>
</li>
<li><strong>IntelMPI</strong>：包含于 <em>Intel Parallel Studio XE</em> 中</li>
</ol>
<h2 id="nvidia-cuda"><a class="header" href="#nvidia-cuda">Nvidia CUDA</a></h2>
<ul>
<li><strong>CUDA Toolkit</strong>：<code>spack install cuda@10.2</code> 以支持不同版本。</li>
<li><strong>PGi Edition</strong>：<code>spack install pgi@19.10</code></li>
</ul>
<h2 id="math-libraries"><a class="header" href="#math-libraries">Math Libraries</a></h2>
<ol>
<li><strong>MKL</strong>：包含于 <em>Intel Parallel Studio XE</em> 中</li>
<li><strong>OpenBLAS</strong>：<code>spack install openblas</code></li>
</ol>
<h2 id="netcdf-io"><a class="header" href="#netcdf-io">NetCDF I/O</a></h2>
<p>用于ASC19 的IO500题目中。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- TITLE: Environment Modules -->
<!-- SUBTITLE: Environment Module Management & Backups -->
<h1 id="modulefile-记录"><a class="header" href="#modulefile-记录">Modulefile 记录</a></h1>
<p>Environment Module: Modulefiles 目录树结构 + 备份</p>
<h2 id="modulefiles-目录树结构"><a class="header" href="#modulefiles-目录树结构">Modulefiles 目录树结构</a></h2>
<pre><code>|- /opt/modulefiles    # 路径并非完全按照冲突关系组织，modulefile 中冲突关系要注意
    |- mpi/
        |- openmpi/
            |- 4.0
            |- 3.1
            |- ...
        |- mpich/
        |- intelmpi/
    |- math/
        |- mkl/
        |- blas/
    |- compilers/
        |- gcc/
        |- icc/
        |- ifort/
    |- cuda/
        |- nvidia/
        |- pgi/
    |- netcdf/
        |- pnetcdf/
        |- netcdf-c/
        |- netcdf-fort/
</code></pre>
<h2 id="备份记录"><a class="header" href="#备份记录">备份记录</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="机器简介"><a class="header" href="#机器简介">机器简介</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
                
    </body>
</html>
